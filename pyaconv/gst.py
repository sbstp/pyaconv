import os

from .fsutil import Path
from . import logging

import gi
gi.require_version('Gst', '1.0')
from gi.repository import GObject, Gst  # noqa

GObject.threads_init()
Gst.init(None)


class BaseEncoder:

    def __init__(self, *, loop, src, dest, eos_cb=None, err_cb=None,
                 props=None):
        pipeline = self.__class__.pipeline(props)
        self._loop = loop
        self._pipeline = Gst.parse_launch(pipeline)
        self._src = self._pipeline.get_by_name("src")
        self._enc = self._pipeline.get_by_name("enc")
        self._dest = self._pipeline.get_by_name("dest")
        self._bus = self._pipeline.get_bus()
        self._eos_cb = eos_cb
        self._err_cb = err_cb

        self._bus.add_watch(0, self._bus_callback, None)

        self._src.set_property("location", src)
        self._dest.set_property("location", dest)

        self.apply_props(props)

    def start(self):
        """
        Start the Gstreamer pipeline, starting the encoding process.
        """
        self._pipeline.set_state(Gst.State.PLAYING)

    def __del__(self):
        self._pipeline.set_state(Gst.State.NULL)

    def _bus_callback(self, bus, message, _):
        # print(Gst.message_type_get_name(message.type))
        if message.type == Gst.MessageType.EOS:
            if self._eos_cb is not None:
                self._eos_cb(self._src.get_property("location"),
                             self._dest.get_property("location"))
        elif message.type == Gst.MessageType.ERROR:
            err, _ = message.parse_error()
            src_elem = None
            if isinstance(message.src, Gst.Element):
                fact = message.src.get_factory()
                src_elem = fact.get_name()
            if self._err_cb is not None:
                self._err_cb(err.message, src_elem)
        else:
            return True
        return False

    def apply_props(self, props):
        """
        Called to apply the properties to the gstreamer encoder module, after initialization.
        """
        raise NotImplementedError

    @classmethod
    def defaults(cls):
        """
        Return a dictionary with the default properties of the encoder.
        """
        raise NotImplementedError

    @classmethod
    def extension(cls):
        """
        Return the extension of files generated by this encoder, e.g. "ogg", "mp3".
        """
        raise NotImplementedError

    @classmethod
    def pipeline(cls, props):
        """
        Return the pipeline string used to initialize this encoder class. There should be a filesrc named src
        and a filesink named dest. The encoder should be named enc. The BaseEncoder will automatically get those
        objects from the pipeline.
        """
        raise NotImplementedError


_OPUS_PIPELINE = """filesrc name=src ! decodebin ! audioconvert ! \
audioresample ! opusenc name=enc ! oggmux ! filesink name=dest"""


class BaseProperty:

    def __init__(self, name, help=None):
        self.name = name
        self.help = help

    def add_argument(self, arg_parser):
        raise NotImplementedError


class Property(BaseProperty):

    def __init__(self, name, *, type, default, help=None):
        super().__init__(name, help)
        self.type = type
        self.default = default

    def add_argument(self, arg_parser):
        if self.type is not bool:
            arg_parser.add_argument("--" + self.name, type=self.type, default=self.default,
                                    help=self.help + " (default: {})".format(self.default))
        else:
            true_def = " (default)" if self.default else ""
            false_def = " (default)" if not self.default else ""
            arg_parser.add_argument("--" + self.name, default=self.default,
                                    help=self.help + true_def, dest=self.name, action="store_true")
            arg_parser.add_argument("--no-" + self.name, default=self.default, help="no " + self.help + false_def,
                                    dest=self.name, action="store_false")


class PropertyEnum(BaseProperty):

    def __init__(self, name, *, values, default, type=str, help=None):
        assert default in values
        super().__init__(name, help)
        self.values = values
        self.default = default
        self.type = type

    def add_argument(self, arg_parser):
        arg_parser.add_argument("--" + self.name, choices=self.values, default=self.default, type=self.type,
                                help=self.help + " (default: {})".format(self.default))


class PropertyRange(BaseProperty):

    def __init__(self, name, *, min, max, default, help=None):
        assert min <= default <= max
        super().__init__(name, help)
        self.min = min
        self.max = max
        self.default = default

    def add_argument(self, arg_parser):
        arg_parser.add_argument("--" + self.name, type=int, choices=range(
            self.min, self.max + 1), default=self.default, help=self.help + " (default: {})".format(self.default),
            metavar="[{}-{}]".format(self.min, self.max))


class OpusEncoder(BaseEncoder):

    def apply_props(self, props):
        self._enc.set_property("bitrate", props["bitrate"])
        Gst.util_set_object_arg(self._enc, "bitrate-type", props["bitrate-type"])
        Gst.util_set_object_arg(self._enc, "audio-type", props["audio-type"])

    @classmethod
    def properties(cls):
        return (
            Property("bitrate", type=int, default=64000, help="bitrate is bits per second"),
            PropertyEnum("bitrate-type", values=["cbr", "vbr", "constrained_vbr"], default="vbr", help="bitrate type"),
            PropertyEnum("audio-type", values=["generic", "voice"],
                         default="generic", help="audio type to optimize for"),
        )

    @classmethod
    def extension(cls):
        return "ogg"

    @classmethod
    def pipeline(cls, _):
        return _OPUS_PIPELINE


_MP3_PIPELINE = """filesrc name=src ! decodebin ! audioconvert ! \
audioresample ! lamemp3enc name=enc ! filesink name=dest"""


class Mp3Encoder(BaseEncoder):

    def apply_props(self, props):
        self._enc.set_property("bitrate", props["bitrate"])
        self._enc.set_property("cbr", props["cbr"])
        self._enc.set_property("mono", props["mono"])
        Gst.util_set_object_arg(self._enc, "encoding-engine-quality", props["encoding-engine-quality"])
        Gst.util_set_object_arg(self._enc, "target", "bitrate")

    @classmethod
    def properties(cls):
        # gst-inspect-1.0 lamemp3enc
        return (
            PropertyRange("bitrate", min=8, max=320, default=128, help="bitrate is kilobits per second"),
            Property("cbr", type=bool, default=False, help="CBR encoding"),
            PropertyEnum("encoding-engine-quality", values=["fast", "standard", "high"],
                         default="high", help="quality/speed of the encoding engine"),
            Property("mono", type=bool, default=False, help="mono encoding"),
        )

    @classmethod
    def extension(cls):
        return "mp3"

    @classmethod
    def pipeline(cls, _):
        return _MP3_PIPELINE


_FLAC_PIPELINE_16 = """filesrc name=src ! decodebin ! audioconvert ! \
audioresample ! audio/x-raw, format=S16LE ! flacenc name=enc ! \
filesink name=dest"""

_FLAC_PIPELINE_24 = """filesrc name=src ! decodebin ! audioconvert ! \
audioresample ! audio/x-raw, format=S24LE ! flacenc name=enc ! \
filesink name=dest"""

_FLAC_PIPELINE_32 = """filesrc name=src ! decodebin ! audioconvert ! \
audioresample ! audio/x-raw, format=S24_32LE ! flacenc name=enc ! \
filesink name=dest"""


class FlacEncoder(BaseEncoder):

    def apply_props(self, props):
        self._enc.set_property("escape-coding", True)
        self._enc.set_property("exhaustive-model-search", True)
        Gst.util_set_object_arg(self._enc, "quality", props["quality"])

    @classmethod
    def properties(cls):
        return (
            PropertyEnum("bit-depth", values=[16, 24, 32], type=int, default=16, help="bit depth per sample"),
            PropertyEnum("quality", values=[str(q) for q in range(0, 9)],
                         default="5", help="compression quality: 0 fastest ; 8 best"),
        )

    @classmethod
    def extension(cls):
        return "flac"

    @classmethod
    def pipeline(cls, props):
        depth = props["bit-depth"]
        if depth == 16:
            return _FLAC_PIPELINE_16
        elif depth == 24:
            return _FLAC_PIPELINE_24
        elif depth == 32:
            return _FLAC_PIPELINE_32
        else:
            raise ValueError("invalid bit depth, expected 16, 24 or 32")


class Worker:

    def __init__(self, loop, queue, journal, finished_cb, encoder, props):
        self._loop = loop
        self._queue = queue
        self._journal = journal
        self._finished = False
        self._finished_cb = finished_cb
        self._encoder = encoder
        self._props = props

    def _eos_cb(self, src, dest):
        dest = Path(dest)
        self._journal.add(dest)
        self._next()

    def _next(self):
        if len(self._queue) > 0:
            src, dest = self._queue.popleft()
            logging.info("encoding {}", src.absolute())
            enc = self._encoder(loop=self._loop, src=src, dest=dest,
                                eos_cb=self._eos_cb,
                                err_cb=self._error,
                                props=self._props)
            enc.start()
        else:
            self._finished = True
            self._finished_cb()

    def start(self):
        self._next()

    @property
    def finished(self):
        return self._finished

    def _error(self, error_msg, src_elem):
        if src_elem is not None:
            logging.error("gstreamer error in element '{}': {}\n", src_elem,
                          error_msg)
        else:
            logging.error("gstreamer error: %s", error_msg)
        self._loop.quit()


class Scheduler:

    def __init__(self, queue, journal, *, encoder, props, threads=None):
        print(props)
        if threads is None:
            threads = max(1, os.cpu_count() - 1)
        self._loop = GObject.MainLoop()
        self._workers = [Worker(self._loop, queue, journal,
                                self._worker_finished, encoder, props)
                         for _ in range(threads)]
        self._has_quit = False

    def _worker_finished(self):
        if all(w.finished for w in self._workers):
            self._has_quit = True
            self._loop.quit()

    def run(self):
        for w in self._workers:
            w.start()
        # check for early exits when the queue is empty
        if not self._has_quit:
            self._loop.run()
